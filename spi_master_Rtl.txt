module spi(
    input wire clk,
    input wire rst,
    input wire tx_enable,
    output reg mosi,
    output reg cs,
    output wire sclk);
 
    typedef enum logic [1:0] {idle = 0, start_tx = 1, tx_data = 2, end_tx = 3 } state_type;
    state_type state, s_next;
    
    
    reg [7:0] din = 8'b10101010;
    reg spi_sclk = 0;
    reg [2:0] ccount = 0;
    reg [2:0] count = 0; 
    integer bit_count = 0;
   
   always@(posedge clk)
      begin
     case(s_next)
     idle: 
     begin
     spi_sclk <= 0;
     end
     
     start_tx : 
     begin
     if(count < 3'b011 || count == 3'b111)
     spi_sclk <= 1'b1;
     else
     spi_sclk <= 1'b0;   
     end
     
     tx_data:
     begin
     if(count < 3'b011 || count == 3'b111)
     spi_sclk <= 1'b1;
     else
     spi_sclk <= 1'b0; 
     end
     
     end_tx: 
     begin
     if(count < 3'b011 )
     spi_sclk <= 1'b1;
     else
     spi_sclk <= 1'b0; 
     end
     
     default : spi_sclk <= 1'b0;
 
     endcase
     end
  
      always@(posedge clk)
      begin
        if(rst)
         state <= idle;
       else
         state <= s_next;
      end
  
     always@(*)
     begin
     case(state)
     
     idle :
     begin
             mosi = 1'b0;
             cs   = 1'b1;
             if(tx_enable)
            s_next = start_tx;
             else
             s_next = idle;
     end
     
     start_tx: 
     begin     
           cs = 1'b0;
           
           if(count == 3'b111)
           s_next = tx_data;
           else
           s_next = start_tx;
     end
     
     tx_data : 
     begin
          mosi = din[7-bit_count];
          if(bit_count != 8) begin
         s_next = tx_data;
          end
          else
          begin
         s_next = end_tx;
          mosi  = 1'b0;
          end
     end
     
     end_tx:
     begin
         cs   = 1'b1;
         mosi = 1'b0;
         if(count == 3'b111)
           s_next = idle;
         else
         s_next = end_tx;
     end
     
     default :  s_next = idle;
     endcase
     end

always@(posedge clk)
begin
case(state)
 
idle : 
begin
count <= 0;
bit_count <= 0;
end
 
 
start_tx : count <= count + 1;
 
 
 
tx_data:
begin
if(bit_count != 8)
        begin
           if(count < 3'b111)
             count <= count + 1;
           else
             begin
             count <= 0;
             bit_count <= bit_count + 1;
             end
        end
end
end_tx : 
begin
count     <= count + 1;
bit_count <= 0;
end
default :
begin
count <= 0;
bit_count <= 0;
end
endcase
end
assign sclk = spi_sclk;
endmodule